JavaScript的两大特性
* 单线程
* 非阻塞

要同时兼容这两大特性，需要深入了解JavaScript的事件循环机制
***
首先了解以下概念

**执行栈**

当调用一个方法时，js会生成这个方法对应的执行环境`context`，又叫执行上下文。

这个执行环境中存在：
* 这个方法的私有作用域
* 上层作用域的指向
* 方法的参数
* 这个作用域中定义的变量
* 这个作用域的this对象

当一系列方法被依次调用时，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方，这个地方被称为执行栈。

**事件队列**

js引擎遇到一个异步事件时，不会一直等待其返回结果，而是会将事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果时，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。

被放入事件队列不会立即执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于空闲状态时，主线程会去查找事件队列中是否有任务。如果有，主线程会取出事件队列中排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码……如此反复，形成循环。

> 可以简单理解为：同步任务存放在执行栈中，异步任务存放在事件队列中，主线程取出对应的任务执行。

**宏任务和微任务**

异步任务分为两类：宏任务`macro task`和微任务`micro task`

宏任务：由宿主（浏览器、node）发起
* `setInterval()`
* `setTimeout()`
* MessageChannel
* I/O 事件队列
* `setImmediate`（node环境）
* script（整体代码块）

微任务：由JS自身发起
* `new Promise()`
* `new MutationObserver()`（浏览器环境）
* requestAnimationFrame
* queueMicrotask

上面说到，在一个事件循环中，异步事件返回结果后会被放到一个任务队列中，其实，根据异步事件的类型，会分别放入对应的宏任务队列和微任务队列。

在当前执行栈为空时，主线程会查看微任务队列中是否有事件存在。如果不存在，就去宏任务队列中取出**一个事件**并把对应的回调加入当前执行栈；如果存在，则会**依次执行**微任务队列中事件的相应回调，直到微任务队列为空，然后再去宏任务队列中取出最前面的**一个事件**，把它相应的回调加入当前执行栈……如此反复，进入循环。

> 当前执行栈执行完毕时，会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。

```
setTimeout(function() {
  console.log(1)
})
new Promise(function (resolve, reject) => {
  console.log(2)
  resolve(3)
}).then(function (val) {
  console.log(val)
})

// 输出结果：2 3 1
```