# chapter 1 课程介绍
### 知识点
* css
  * 布局
  * 定位
  * 移动端响应式
* ES 语法
  * 原型 原型链
  * 作用域 闭包
  * 异步 单线程
* Web API
  * DOM BOM
  * Ajax 跨域
  * 事件 存储
* 开发环境
  * 版本管理
  * 调试抓包
  * 打包构建
* 运行环境
  * 页面渲染
  * 性能优化
  * Web 安全
* 网络通讯
  * headers
  * Restful API
  * 缓存策略

### 从哪些方面梳理
* W3C 标准 JS 基础语法
* ECMA 262 标准 JS-Web-API
* 开发环境
* 运行环境

# chapter 3 HTML CSS 面试题
### HTML 面试题
1. 如何理解 HTML 语义化
   * 让人更容易读懂（增加代码可读性）
   * 让搜索引擎更容易读懂（SEO）
2. 默认情况下，哪些 HTML 标签是块级元素，哪些是内联元素？
   * `display: block/table;` 有 div h1 h2 table ul ol p 等
   * `display: inline/inline-block;` 有 span img input button 等
### CSS 面试题 分析知识模块
#### 布局
1. 盒子模型的宽度如何计算
   * offsetWidth = （内容宽度 + 内边距 + 边框），无外边距
   * 如果让 offsetWidth 为 100px 应该怎么做？
   > 代码见 盒模型.html
2. margin 纵向重叠问题
   * 相邻元素的 margin-top 和 margin-bottom 会发生重叠
   * 空白内容的 p 标签也会重叠
   > 代码见 margin-纵向重叠.html
3. margin 负值的问题
   * margin-top 和 margin-left 负值，元素向上、向左移动
   * margin-right 负值，右侧元素左移，自身不受影响
   * margin-bottom 负值，下方元素上移，自身不受影响
   > 代码见 margin-负值.html
4. BFC 的理解和应用
   * Block format context 块级格式化上下文
   * 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素
   * 形成 BFC 的常见条件：1.float 不是 none 2.position 是 absolute 或 fixed 3.overflow 不是 visible 4.display 是 flex inline-block 等
   * BFC的常见应用：清除浮动
   > 代码见 bfc.html
5. float 布局的问题，以及 clearfix
   * 圣杯布局和双飞翼布局的目的
     * 三栏布局，中间一栏最先加载和渲染（内容最重要）
     * 两侧内容固定，中间内容随着宽度自适应
     * 一般用于 PC 网页
   * 技术总结：
     * 使用 float 布局
     * 两侧使用 margin 负值，以便和中间内容横向重叠
     * 防止中间内容被两侧覆盖，可以用 padding 或 margin 来防止
   > 代码见 圣杯布局.html 双飞翼布局.html
   * 手写 clearfix
   > 代码见 圣杯布局.html
6. flex 画色子
   * flex 实现一个三点的色子
   > 代码见 flex.html
#### 定位
1. absolute 和 relative 分别依据什么定位
   * relative 依据自身定位
   * absolute 依据最近一层的定位元素定位：往上找父元素中的定位元素（absolute/relative/fixed）直到body
   > 代码见 absolute-relative.html
2. 居中对齐有哪些实现方式
   * 水平居中
     * inline 元素： text-align: center;
     * block 元素： margin: auto;
     * absolute 元素： left: 50%; + margin-left: -{{width / 2}}px
   * 垂直居中
     * inline 元素： line-height: {{height}}px
     * absolute 元素： top: 50%; + margin-top: -{{height / 2}}px
     * absolute 元素： transform(-50%, -50%)
     * absolute 元素： top, left, bottom, right = 0 + margin: auto;
#### 图文样式
* line-height 的继承问题
  > 代码见 line-height继承.html
#### 响应式
1. rem 是什么
   * px 绝对长度单位 常用
   * em 相对长度单位 相对于父元素 不常用
   * rem 相对长度单位 相对于根元素 常用于响应式布局
   > 代码见 rem.html
2. 如何实现响应式
   * media-query 根据不同的屏幕宽度设置根元素 font-size
   * rem 基于根元素的相对单位
   > 代码见 响应式.html
   * rem的弊端：阶梯性
   * 网页视口尺寸 
     * window.screen.height // 屏幕高度 
     * window.innerHeight // 网页视口高度 
     * document.body.clientHeight // body高度
   * vh-网页视口高度的1/100 vw-网页视口宽度的1/100
   * vmax 取vw和vh的较大值 vmin 取两者的较小值

# chapter 4 JS基础-变量类型和计算
### 值类型和引用类型的区别
``` javascript
// 值类型
let a = 10
let b = a
a = 20
console.log(b) // 10
// 引用类型
let a = { age: 20 }
let b = a
b.age = 21
console.log(a.age) // 21

const n = null // 特殊引用类型  指针指向空地址
function fn() {} // 特殊引用类型 但不用于存储数据 所以没有拷贝 复制一说
```
### typeof 运算符
* 识别所有值类型：undefined string number boolean symbol
* 识别函数：function
* 判断是否是引用类型（不可再细分）：object
``` javascript
typeof console.log // 'function'
typeof function(){} // 'function'
typeof null // 'object'
typeof ['a', 'b'] // 'object'
typeof { x: 100 } // 'object'
```

### 深拷贝
* 代码见 deepClone.js

### 变量计算 - 类型转换
* 字符串拼接
* ==
* if 语句和逻辑运算
``` javascript
const a = 100 + 10 // 110
const b = 100 + '10' // '10010'
const c = true + '10' // 'true10'

100 == '100' // true
0 == '' // true
0 == false // true
false == '' // true
null == undefined // true

// 除了 == null 之外，其他都一律用 === ，例如：
const obj = { x: 100 }
if (obj.a == null) {} // 简写
// 相当于 if (obj.a === null || obj.a === undefined) {}

// 以下都是 falsely 变量，除此之外都是 truely 变量
!!0 === false
!!NaN === false
!!'' === false
!!null === false
!!undefined === false
!!false === false

10 && 0 // 0
'' || 'abc' // 'abc'
!window.abc // true
```
### 小结
* 值类型 vs 引用类型，堆栈模型，深拷贝
* typeof 运算符
* 类型转换，truly 和 falsely 变量

# chapter 5 JS基础-原型和原型链
### 原型和原型链
* 如何准确判断一个变量是不是数组？
  * a instanceof Array
* 手写一个简易的 jQuery ，考虑插件和扩展性
  * 代码见 jquery-demo
* class 的原型本质，怎么理解？
  * 原型和原型链的图示
  * 属性和方法的执行规则

### class
* constructor
* 属性
* 方法
* 代码见 class-demo.js

### 继承
* extends
* super
* 扩展或重写方法
* 代码见 class-demo.js

### 类型判断 - instanceof
``` javascript
// 基于 class-demo
xiaoming instanceof Student
xiaoming instanceof People)
xiaoming instanceof Object
[] instanceof Array // true
[] instanceof Object // true
{} instanceof Object // true
```

### 原型
``` javascript
// 基于 class-demo
// class 实际上是函数，可见是一种语法糖
typeof People // 'function'
typeof Student // 'function'

// 隐式原型和显式原型
xiaoming.__proto__
Student.prototype
xiaoming.__proto === Student.prototype // true
```

### 原型关系
* 每个 class 都有显式原型 prototype
* 每个实例都有隐式原型 \_\_proto\_\_
* 实例的 \_\_proto\_\_ 指向对应 class 的 prototype

### 基于原型的执行规则
* 获取属性 xiaoming.name 或执行方法 xiaoming.sayHi() 时
* 先在自身属性和方法寻找
* 如果找不到则自动去 \_\_proto\_\_ 中查找

### 原型链
``` javascript
// 基于 class-demo
Student.prototype.__proto__
People.prototype
Student.prototype.__proto__ === People.prototype
```
> `xiaoming instanceof Studeng // true`   
> xiaoming 顺着原型链往上找 能否找到 Student.prototype

### 小结
* class 和继承，结合上面手写 jQuery 的示例来理解
* instanceof
* 原型和原型链：图示 & 执行规则

# chapter 6 JS基础-作用域和闭包
### 题目
* this 的不同应用场景，如何取值？
* 手写 bind 函数
  > 代码见 bind-demo.js
* 实际开发中闭包的应用场景，举例说明
  * 隐藏数据
  * 做一个简单的 cache 工具，代码见 cache-demo
``` javascript
// 创建 10 个 a 标签 点击时弹出对应的序号
for (let i = 0; i < 10; i++) {
  let a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function(e) {
    e.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}
```

### 知识点
* 作用域和自由变量
* 闭包
* this

### 作用域
* 全局作用域
* 函数作用域
* 块级作用域（ES6新增）

### 自由变量
* 一个变量在当前作用域没有定义，但被使用了
* 向上级作用域，一层一层依次寻找，直到找到为止
* 如果到全局作用域都没找到，则报错 xx is not defined

### 闭包
* 作用域应用的特殊情况，有两种表现：
* 函数作为参数被传递
* 函数作为返回值被返回
> 闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在执行的地方！！

> 代码见 closure.js

### this
* 作为普通函数 this === window e.g. setTimeout
* 使用 call apply bind this === 传入的第一个参数
* 作为对象方法被调用 this === 对象本身
* 在 class 方法中调用 this === 当前实例本身
* 箭头函数 this === 找上级作用域的this来确定
> this 取值是在函数执行时确定的 不是函数定义时确定的！
``` javascript
function fn1() {
  console.log(this)
}
fn1() // window

fn1.call({ x: 100}) // { x: 100 }

const fn2 = fn1.bind({ x: 200 })
fn2() // { x: 200 }
```
``` javascript
const zhangsan = {
  name: '张三',
  sayHi() {
    // this 即当前对象
    console.log(this)
  },
  wait() {
    setTimeout(function() {
      // this === window
      console.log(this)
    })
  },
  waitAgain() {
    setTimeout(() => {
      // this 即当前对象
      console.log(this)
    })
  }
}
```
### bind apply call 的区别
* 三者都可以改变函数的 this 指向
* 三者的第一个参数都是 this 要指向的对象，如果没有这个参数或这个参数传入 undefined 或 null ，则默认指向全局 window
* 三者都可以传参，但 apply 是数组，而 call bind 是参数列表，且 apply 和 call 是一次性传入参数，而 bind可以分为多次传入
* bind 是返回绑定 this 之后的函数，便于稍后调用； apply call 则是立即执行
### 小结
* 作用域和自由变量
* 闭包：两种常见方式 & 自由变量查找规则
* this

# chapter 7 JS基础-异步
### 题目
* 同步和异步的区别是什么？  
* 手写用 promise 加载一张图片
  > 代码见 promise-demo.js
* 前端使用异步的场景有哪些？
* setTimeout 笔试题
  ``` javascript
  console.log(1)
  setTimeout(function() {
    console.log(2)
  }, 1000)
  console.log(3)
  setTimeout(function() {
    console.log(4)
  }, 0)
  console.log(5)
  ```
### 知识点
* 单线程和异步
* 应用场景
* callback hell 和 promise

### 单线程和异步
* JS 是单线程语言，只能同时做一件事
* 浏览器和 nodejs 已支持 JS 启动进程，如 web worker
* JS 和 dom 渲染共用同一个线程，因为 JS 可修改 dom 结构
* 遇到等待（网络请求，定时任务）不能卡住
* 需要异步
* 回调 callback 函数形式

### 异步和同步
* 基于 JS 是单线程语言
* 异步不会阻塞代码执行
* 同步会阻塞代码执行

### 应用场景
* 网络请求，如 ajax 图片加载
* 定时任务，如 setTimeout

### callback hell
``` javascript
// 获取第一份数据
$.get(url1, data1 => {
  console.log(data1)
  // 获取第二份数据
  $.get(url2, data2 => {
    console.log(data2)
    // 获取第三份数据
    $.get(url3, data3 => {
      console.log(data3)
      // 还可能获取更多数据
    })
  })
})
```
### promise
``` javascript
function getData(url) {
  return new Promise((resolve, reject) => {
    $.ajax({
      url,
      success(data) {
        resolve(data)
      },
      error(err) {
        reject(err)
      }
    })
  })
}
const url1 = '/data1.json'
const url2 = '/data2.json'
const url3 = '/data3.json'
getData(url1).then(data1 => {
  console.log(data1)
  return getData(url2)
}).then(data2 => {
  console.log(data2)
  return getData(url3)
}).then(data3 => {
  console.log(data3)
}).catch(err => {
  console.error(err)
})
```

# chapter 8 JS 异步-进阶
### 题目
* 请描述 event loop 的机制，可画图
* 什么是宏任务和微任务，两者有什么区别？
* Promise 有哪三种状态？如何变化？
* 场景题 promise then 和 catch 的连接
  ``` js
  // 第一题 1 3
  Promise.resolve().then(() => {
    console.log(1)
  }).catch(() => {
    console.log(2)
  }).then(() => {
    console.log(3)
  })
  // 第二题 1 2 3
  Promise.resolve().then(() => {
    console.log(1)
    throw new Error('error1')
  }).catch(() => {
    console.log(2)
  }).then(() => {
    console.log(3)
  })
  // 第三题 1 2
  Promise.resolve().then(() => {
    console.log(1)
    throw new Error('error1')
  }).catch(() => {
    console.log(2)
  }).catch(() => {
    console.log(3)
  })
  ```
* 场景题 async/await 语法
* 场景题 promise 和 setTimeout 的顺序
  > 代码见 macro-micro.js
* 场景题 外加 async/await 的顺序问题
  > 代码见 macro-micro.js

### event loop
* JS 是单线程运行的
* 异步要基于回调来实现
* event loop 就是异步回调的实现原理

### 总结 event loop 过程
1. 同步代码，一行一行放在 Call Stack 中执行
2. 遇到异步，会先“记录”下来，等待时机（定时、网络请求等）
3. 时机到了，就移动到 Callback Queue
4. 如果 Call Stack 为空（即同步代码执行完） Event Loop 开始工作
5. 轮询查找 Callback Queue ，如有则移动到 Call Stack 执行
6. 然后继续轮询查找（永动机一样）
> DOM 事件、setTimeout、ajax都是使用回调，基于 event loop

### promise 的三种状态
* pending resolved rejected
* pending -> resolved 或 pending -> rejected
* 变化不可逆

### 状态的表现
* pending 状态 不会触发 then 和catch
* resolved 状态 会触发后续的 then 回调函数
* rejected 状态 会触发后续的 catch 回调函数

### then 和 catch 改变状态
* then 正常返回 resolved，里面有报错则返回 rejected
``` js
const p1 = Promise.resolve().then(() => {
  return 100
})
console.log('p1', p1) // resolved，触发后续 then 回调
p1.then(() => {
  console.log('123')
})
const p2 = Promise.resolve().then(() => {
  throw new Error('then error')
})
console.log('p2', p2) // rejected，触发后续 catch 回调
p2.then(() => {
  console.log('456')
}).catch((err) => {
  console.log('error456', err)
})
```
* catch 正常返回 resolved，里面有报错则返回 rejected
``` js
const p3 = Promise.reject('my error').catch(err => {
  console.error('err', err)
})
console.log('p3', p3) // resolved，注意！触发 then 回调
p3.then(() => {
  console.log(100)
})
const p4 = Promise.reject('my error').catch(err =>{
  throw new Error('catch error')
})
console.log('p4', p4) // rejected，触发 catch 回调
p4.then(() => {
  console.log(200)
}).catch(() => {
  console.log('some err')
}) // resolved，因为cache没有报错，所以此处返回resolved状态的promise
```

### async/await
* 执行 async 函数，返回的是 Promise 对象
* await 相当于 Promise 的 then
* try...catch 可捕获异常，代替了 Promise 的 catch
> 代码见 async.js
> 示例见 async-demo.js

### for...of
* for...in (以及 forEach for) 是常规的同步遍历
* for-of 常用于异步的遍历
> 代码见 for-of.js

### 宏任务 macroTask 和微任务 microTask
* 宏任务：setTimeout、setInterval、Ajax、DOM 事件
* 微任务：Promise、async/await
* 微任务执行时机比宏任务要早

### event loop 和 DOM 渲染
* 每次 Call Stack 清空（即每次轮询结束），即同步任务执行完
* 都是 DOM 重新渲染的机会，DOM 结构如有改变则重新渲染
* 然后再去触发下一次 Event Loop

### 微任务和宏任务的区别
* 微任务：DOM 渲染前触发，如 Promise，是 ES6 语法规定的
* 宏任务：DOM 渲染后触发，如 setTimeout，是由浏览器规定的 

# chapter 9 JS Web API DOM
### JS Web API
* DOM
* BOM
* 事件绑定
* ajax
* 存储
### 题目
* DOM 是哪种数据结构
* DOM 操作的常用 API
* attr 和 property 的区别
* 一次性插入多个 dom 节点，考虑性能
### 知识点
* DOM 本质-树
* DOM 节点操作
* DOM 结构操作
* DOM 性能

### DOM 节点操作
* 获取 DOM 节点
* attribute
* property
> 代码见 dom.html

### property 和 attribute
* property: 修改对象属性，不会体现到 html 结构中
* attribute: 修改 html 属性，会改变 html 结构
* 两者都有可能引起 DOM 重新渲染

### DOM 结构操作
> 代码见 dom.html

### DOM 性能
* DOM 操作非常昂贵，避免频繁的 DOM 操作
* 对 DOM 查询做缓存
  ``` javascript
  // 不缓存 dom 查询结果
  for (let i = 0; i < document.getElementsByTagName('p').length; i++) {
    // 每次循环，都会计算 length ，频繁进行 dom 查询
  }
  // 缓存 dom 查询结果
  const pList = document.getElementsByTagName('p')
  const length = pList.length
  for (let i = 0; i < length; i++) {
    // 缓存 length ，只进行一次 dom 查询
  }
  ```
* 将频繁操作改为一次性操作
  > 代码见 dom.html


# chapter 10 JS-Web-API-BOM (Browser Object Model)
### 题目
* 如何识别浏览器的类型 navigarot
* 分析拆解 url 各个部分 location
### 知识点
* navigator
* screen
* location
* history
### navigator 和 screen
``` javascript
// navigator
const ua = navigator.userAgent
const isChrome = ua.indexOf('Chrome') !== -1
console.log(isChrome)
// screen
console.log(screen.width)
console.log(screen.height)
```
### location 和 history
``` javascript
// location
console.log(location.href)
console.log(location.protocol) // 'http:' 'https:'
console.log(location.pathname)
console.log(location.search)
console.log(location.hash)
// history
history.back()
history.forward()
```

# chapter 11 JS-Web-API-事件
### 题目
* 编写一个通用的事件监听函数
  > 考虑代理和通用 代码见 event-demo.js
* 描述事件冒泡的流程
  * 基于 DOM 树形结构
  * 事件会顺着触发元素向上冒泡
  * 应用场景：代理
* 无限上滑的图片列表，如何监听每个图片的点击？
  * 事件代理
  * 用 e.target 获取触发元素
  * 用 matches 来判断是否是触发元素
### 知识点
* 事件绑定
* 事件冒泡
* 事件代理

### 事件绑定
> 代码见 event-demo.js
### 事件冒泡
> 代码见 event-demo.js
### 事件代理
* 代码简洁
* 减少浏览器内存占用
* 但是不要滥用代理
> 代码见 event-demo.js

# chapter 12 ajax
### 题目
* 手写一个简易的 ajax
  > 代码见 ajax.js
* 跨域的常用实现方式

### 知识点
* XMLHttpRequest
* 状态码
* 跨域：同源策略，跨域解决方案

### XMLHttpRequest
> 代码见 ajax.js

### xhr.readyState
* 0 - （未初始化）还没有调用send()方法
* 1 - （载入）已调用send()方法，正在发送请求
* 2 - （载入完成）send()方法执行完成，已经接收到全部响应内容
* 3 - （交互）正在解析响应内容
* 4 - （完成）响应内容解析完成，可以在客户端调用
### xhr.status
* 2xx - 表示成功处理请求，如 200
* 3xx - 需要重定向，浏览器直接跳转，如 301 302 304
  * 301 永久重定向，浏览器主动跳掉重定向的地址
  * 302 临时重定向
  * 304 资源未改变，浏览器直接使用缓存的资源
* 4xx - 客户端请求错误，如 404 403
  * 404 找不到请求
  * 403 没有权限
* 5xx - 服务器端错误

### 跨域
* 什么是跨域（同源策略
* JSONP
* CORS（服务端支持）

### 同源策略
* ajax 请求时，浏览器要求当前网页和 server 必须同源（安全）
* 同源：协议、域名、端口三者必须一致
* 前端： http://a.com:8080/ server： https://b.com/api/xxx

### 加载图片 css js 可无视同源策略
* `<img src=跨域的图片地址 />`
* `<link href=跨域的css地址 />`
* `<script src=跨域的js地址></script>`
* `<img />` 可用于统计打点，可使用第三方统计服务
* `<link /> <script>` 可使用 CDN，CDN一般都是外域
* `<script>` 可实现 JSONP

### 跨域
* 所有的跨域，都必须经过 server 端允许和配合
* 未经 server 端允许就实现跨域，说明浏览器有漏洞，危险信号
### JSONP
* `<script>` 可绕过跨域限制
* 服务器可以任意动态拼接数据返回
* 所以，`<script>` 就可以获得跨域的数据，只要服务端愿意返回
> 代码见 jsonp.html

### jquery 实现 JSONP
``` javascript
$.ajax({
  url: 'http://localhost:8080/x-origin.json',
  dataType: 'jsonp',
  jsonpcallback: 'callback',
  success: function (data) {
    console.log(data)
  }
})
```

### CORS - 服务器设置 http header
``` javascript
// 第二个参数填写允许跨域的域名称，不建议直接写 "*"
response.setHeader("Access-Control-Allow-Origin", "http://localhost:8081");
response.setHeader("Access-Control-Allow-Headers", "X-Requested-With");
response.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
// 接收跨域的 cookie
response.setHeader("Access-Control-Allow-Credentials", "true");
```

### 跨域的实现方式
* JSONP
* CORS
### ajax 常用工具
* jQuery
* fetch
* axios

# chapter 13 JS-Web-API-存储
### 题目
* 描述 cookie localStorage sessionStorage 的区别

### cookie
* 本身用于浏览器和 server 通讯
* html5 之前 没有localStorage和sessionStorage cookie也可用于本地存储
* 可用 document.cookie = '...' 来修改

### cookie 的缺点
* 存储大小，最大4kb
* http 请求时需要发送到服务端，增加请求数据量
* 只能用 document.cookie='a=10' 来修改，太过简陋

### localStorage 和 sessionStorage
* 相同点
  * html5 专门为存储而设计，最大可存 5M
  * API 简单易用 setItem getItem
  * 不会随着 http 请求被发送出去
* 不同点
  * localStorage 数据会永久存储，除非代码或手动删除
  * sessionStorage 只存在于当前会话，浏览器关闭则清空
  * 一般用 localStorage 更多一些

### 三者区别
* 容量
* API 易用性
* 是否跟随 http 请求发送出去

# chapter 14 HTTP 面试题
### 题目
* http 常见的状态码有哪些？
* http 常见的 header 有哪些？
* 什么是 Restful API
* 描述一下 http 的缓存机制（重要）

### http 状态码
* 状态码分类
  * 1xx 服务器收到请求
  * 2xx 请求成功 如200
  * 3xx 重定向 如302
  * 4xx 客户端错误 如404
  * 5xx 服务端错误 如500
* 常见状态码
  * 200 成功
  * 301 永久重定向（配合location，浏览器自动处理）浏览器下次直接访问新地址
  * 302 临时重定向（配合location，浏览器自动处理）浏览器下次仍然访问老地址 应用：短网址、百度搜索时会先跳转百度的链接 再通过302到目标网址
  * 304 资源未被修改
  * 404 资源未找到
  * 403 没有权限
  * 500 服务器错误
  * 504 网关超时

### Restful API
* 传统 API 设计：把每个 url 当做一个功能
* Restful API 设计：把每个 url 当做一个唯一的资源
* 如何设计成一个资源？
  * 尽量不用 url 参数
  * 用 method 表示操作类型

### http headers
* 常见的 Request Headers
  * Accept 浏览器可接收的数据格式
  * Accept-Encoding 浏览器可接收的压缩算法，如 gzip
  * Accept-Language 浏览器可接收的语言，如 zh-CN
  * Connection: keep-alive 一次TCP连接重复使用
  * Cookie
  * Host 请求的域名
  * User-Agent 浏览器信息
  * Content-type 发送数据的格式，如 application/json
* 常见的 Response Headers
  * Content-type 返回数据的格式，如 application/json
  * Content-length 返回数据的大小，多少字节
  * Content-Encoding 返回数据的压缩算法，如 gzip
  * Set-Cookie
* 自定义 header
  * `headers: {'X-Requestd-With': 'XMLHttpRequest'}`
* 缓存相关的 headers
  * Cache-Control Expires
  * Last-Modified If-Modified-Since
  * Etag If-None-Match

### 强制缓存
* 客户端缓存资源
* Cache-Control
  * 在 response headers 中
  * 控制强制缓存的逻辑
  * 例如 Cache-Control: max-age=31536000 (单位是秒) 缓存一年
  * Cache-Control 的值：max-age no-cache no-store private public
* 关于 Expires
  * 同在 response headers 中
  * 同为控制缓存过期
  * 已被 Cache-Control 代替
### 协商缓存
* 服务器端缓存策略
* 服务器判断客户端资源，是否和服务端资源一样
* 一致则返回304，否则返回200和最新的资源
* 客户端初次请求，服务端返回资源和资源标识；客户端带着资源标识再次请求，服务端判断标识是否有效，返回304或者新的资源和新的标识
* 资源标识
  * 在 Response Headers 中，有两种
  * Last-Modified 资源的最后修改时间 客户端带着 If-Modified-Since
  * Etag 资源的唯一标识（一个字符串，类似hash） 客户端带着 If-None-Match
  * 会优先使用 Etag ，Last-Modified 只能精确到秒级，且如果资源被重复生成，而内容不变，则 Etag更精确

### 刷新操作
* 正常操作：强制缓存有效，协商缓存有效 访问url 跳转链接 前进后退
* 手动刷新：强制缓存失效，协商缓存有效 f5
* 强制刷新：强制缓存失效，协商缓存失效 ctrl + f5

# chapter 15 开发环境
* git
* 调试工具
* 抓包
* webpack babel
* linux 常用命令

### 常用 git 命令
``` bash
git add .
git checkout xxx
git commit -m 'xxx'
git push origin master
git pull origin master
git branch
git checkout -b xxx / git checkout xxx
git merge xxx
```

### webpack 和 babel
> 代码见 webpack-demo

<!-- todo 15-8 -->
### linux 命令
``` bash
ssh work@192.168.0.1 // 连接服务器 work是用户名
ls -a // 显示所有文件
ll // 列表形式看文件
mkdir abc // 创建abc文件夹
rm -rf abc // 删除文件夹
mv index.js index1.js // 修改文件名为 index1.js
mv bundle.js ../bundle.js // 移动文件到上级目录
cp a.js a1.js // 复制a.js 设置名为a1.js
touch d.js // 新建d.js
vi d.js // 新建d.js 并且进入vim编辑器
cat head tail // 查看文件/文件前几行/后几行
grep "babel" package.json // 查找关键字
```

# chapter 16 运行环境
* 网页加载过程
* 性能优化
* 安全

### 页面加载过程
* 从输入 url 到渲染出页面的整个过程
    * 下载资源：各个资源类型，下载过程
    * 渲染页面：结合 html css javascript 图片等
* window.onload 和 DOMContentLoaded 的区别
  ``` javascript
  window.addEventListener('load', function () {
    // 页面全部资源加载完才会执行，包括图片、视频、iframe 等
  })
  document.addEventListener('DOMContentLoaded', function () {
    // DOM 渲染完即可执行，此时图片、视频可能还没有加载完
  })
  ```

### 资源的形式
* html 代码
* 媒体文件，如图片、视频等
* javascript css

### 加载过程
* DNS 解析：域名 -> IP 地址
* 浏览器根据 IP 地址向服务器发起 http 请求
* 服务器处理 http 请求，并返回给浏览器

### 渲染过程
* 根据 HTML 代码生成 DOM Tree
* 根据 CSS 代码生成 CSSOM
* 将 DOM Tree 和 CSSOM 整合形成 Render Tree
* 根据 Render Tree 渲染页面
* 遇到 `<script>` 则暂停渲染，优先加载并执行 JS 代码，完成再继续
* 直至把 Render Tree 渲染完成
> css 放在 head 中，js 放在 body 最后

### 性能优化原则
* 多使用内存、缓存或其他方法
* 减少 CPU 计算量，减少网络加载耗时
* 适用于所有编程的性能优化 -- 空间换时间
* 从让加载、渲染更快入手

### 让加载更快
* 减少资源体积：压缩代码
* 减少访问次数：合并代码、SSR服务端渲染、缓存
* 使用更快的网络：CDN

### 让渲染更快
* css 放在 head，js放在 body 下面
* 尽早开始执行 js，用 DOMContentLoaded 触发
* 懒加载（图片懒加载，上滑加载更多）
* 对 DOM 查询进行缓存
* 频繁 DOM 操作，合并到一起插入 DOM 结构
* 节流 throttle 防抖 debounce

### 缓存
* 静态资源加 hash 后缀，根据文件内容自动计算 hash 
* 文件内容不变，则 hash 不变，则 url 不变
* url 和文件不变，则会自动触发 http 缓存机制，返回 304

### 懒加载
``` html
<img id="img1" src="preview.png" data-realsrc="abc.png"/>
<script type="text/javascript">
  var img1 = document.getElementById('img1')
  img1.src = img1.getAttribute('data-realsrc')
</script>
```

### 防抖 debounce
* 监听一个输入框，文字变化后触发 change 事件
* 直接用 keyup 事件，则会频繁触发 change 事件
* 防抖：用户输入结束或暂停时，才会触发 change 事件

### 节流 throttle
* 拖拽一个元素时，要随时拿到该元素被拖拽的位置
* 直接用 drag 事件，则会频繁触发，很容易导致卡顿
* 节流：无论拖拽速度多快，都会每隔 100ms 触发一次

### 安全
* 问题：常见的 web 前端攻击方式有哪些？
* XSS 跨站请求攻击
* XSRF 跨站请求伪造
  
### XSS 预防
* 替换特殊字符，如 `<` 变为 `&lt;` `>` 变为 `&gt;`
* `<script>` 变为 `&lt;script&gt;` 直接显示，而不会作为脚本执行
* 前后端可以都做替换，双重保险

### XSRF 预防
* 使用 post 接口
* 增加验证，例如密码、短信验证码等

# chapter 17 课程总结
思维导图见 xmind

# chapter 18 真题
### 介绍 RAF requestAnimationFrame
* 要想动画流畅，更新频率要 60 帧每秒，即 16.67ms 更新一次视图
* setTimeout 要手动控制频率，而 RAF 浏览器会自动控制
* 后台标签或隐藏 iframe 中，RAF 会暂停，而 setTimeout 依然执行
> 代码见 raf.html

### 如何性能优化 从哪几个方面考虑
