# chapter 1
### 知识点
* css
  * 布局
  * 定位
  * 移动端响应式
* ES 语法
  * 原型 原型链
  * 作用域 闭包
  * 异步 单线程
* Web API
  * DOM BOM
  * Ajax 跨域
  * 事件 存储
* 开发环境
  * 版本管理
  * 调试抓包
  * 打包构建
* 运行环境
  * 页面渲染
  * 性能优化
  * Web 安全
* 网络通讯
  * headers
  * Restful API
  * 缓存策略

# chapter 2
### typeof 运算符
* 识别所有值类型：undefined string number boolean symbol
* 识别函数：function
* 判断是否是引用类型（不可再细分）：object
``` javascript
typeof console.log // 'function'
typeof function(){} // 'function'
typeof null // 'object'
typeof ['a', 'b'] // 'object'
typeof { x: 100 } // 'object'
```

### 深拷贝
* 代码见 deepClone.js

### 变量计算 - 类型转换
* 字符串拼接
* ==
* if 语句和逻辑运算
``` javascript
const a = 100 + 10 // 110
const b = 100 + '10' // '10010'
const c = true + '10' // 'true10'

100 == '100' // true
0 == '' // true
0 == false // true
false == '' // true
null == undefined // true

// 除了 == null 之外，其他都一律用 === ，例如：
const obj = { x: 100 }
if (obj.a == null) {} // 简写
// 相当于 if (obj.a === null || obj.a === undefined) {}

// 以下都是 falsely 变量，除此之外都是 truely 变量
!!0 === false
!!NaN === false
!!'' === false
!!null === false
!!undefined === false
!!false === false

10 && 0 // 0
'' || 'abc' // 'abc'
!window.abc // true
```
### 小结
* 值类型 vs 引用类型，堆栈模型，深拷贝
* typeof 运算符
* 类型转换，truly 和 falsely 变量

## chapter 3
### 原型和原型链
* 如何准确判断一个变量是不是数组？
  * a instanceof Array
* 手写一个简易的 jQuery ，考虑插件和扩展性
  * 代码见 jquery-demo
* class 的原型本质，怎么理解？
  * 原型和原型链的图示
  * 属性和方法的执行规则

### class
* constructor
* 属性
* 方法
* 代码见 class-demo.js

### 继承
* extends
* super
* 扩展或重写方法
* 代码见 class-demo.js

### 类型判断 - instanceof
``` javascript
// 基于 class-demo
xiaoming instanceof Student
xiaoming instanceof People)
xiaoming instanceof Object
[] instanceof Array // true
[] instanceof Object // true
{} instanceof Object // true
```

### 原型
``` javascript
// 基于 class-demo
// class 实际上是函数，可见是一种语法糖
typeof People // 'function'
typeof Student // 'function'

// 隐式原型和显式原型
xiaoming.__proto__
Student.prototype
xiaoming.__proto === Student.prototype // true
```

### 原型关系
* 每个 class 都有显式原型 prototype
* 每个实例都有隐式原型 \_\_proto\_\_
* 实例的 \_\_proto\_\_ 指向对应 class 的 prototype

### 基于原型的执行规则
* 获取属性 xiaoming.name 或执行方法 xiaoming.sayHi() 时
* 先在自身属性和方法寻找
* 如果找不到则自动去 \_\_proto\_\_ 中查找

### 原型链
``` javascript
// 基于 class-demo
Student.prototype.__proto__
People.prototype
Student.prototype.__proto__ === People.prototype
```
> `xiaoming instanceof Studeng // true`   
> xiaoming 顺着原型链往上找 能否找到 Student.prototype

### 小结
* class 和继承，结合上面手写 jQuery 的示例来理解
* instanceof
* 原型和原型链：图示 & 执行规则

# chapter 5 异步和单线程
### 题目
* 同步和异步的区别是什么？  
* 手写用 promise 加载一张图片
  > 代码见 promise-demo.js
* 前端使用异步的场景有哪些？
* setTimeout 笔试题
  ``` javascript
  console.log(1)
  setTimeout(function() {
    console.log(2)
  }, 1000)
  console.log(3)
  setTimeout(function() {
    console.log(4)
  }, 0)
  console.log(5)
  ```
### 知识点
* 单线程和异步
* 应用场景
* callback hell 和 promise

### 单线程和异步
* JS 是单线程语言，只能同时做一件事
* 浏览器和 nodejs 已支持 JS 启动进程，如 web worker
* JS 和 dom 渲染共用同一个线程，因为 JS 可修改 dom 结构
* 遇到等待（网络请求，定时任务）不能卡住
* 需要异步
* 回调 callback 函数形式

### 异步和同步
* 基于 JS 是单线程语言
* 异步不会阻塞代码执行
* 同步会阻塞代码执行

### 应用场景
* 网络请求，如 ajax 图片加载
* 定时任务，如 setTimeout

### callback hell
``` javascript
// 获取第一份数据
$.get(url1, data1 => {
  console.log(data1)
  // 获取第二份数据
  $.get(url2, data2 => {
    console.log(data2)
    // 获取第三份数据
    $.get(url3, data3 => {
      console.log(data3)
      // 还可能获取更多数据
    })
  })
})
```
### promise
``` javascript
function getData(url) {
  return new Promise((resolve, reject) => {
    $.ajax({
      url,
      success(data) {
        resolve(data)
      },
      error(err) {
        reject(err)
      }
    })
  })
}
const url1 = '/data1.json'
const url2 = '/data2.json'
const url3 = '/data3.json'
getData(url1).then(data1 => {
  console.log(data1)
  return getData(url2)
}).then(data2 => {
  console.log(data2)
  return getData(url3)
}).then(data3 => {
  console.log(data3)
}).catch(err => {
  console.error(err)
})
```

# chapter 7 JS-Web-API-BOM (Browser Object Model)
### 题目
* 如何识别浏览器的类型 navigarot
* 分析拆解 url 各个部分 location
### 知识点
* navigator
* screen
* location
* history
### navigator 和 screen
``` javascript
// navigator
const ua = navigator.userAgent
const isChrome = ua.indexOf('Chrome') !== -1
console.log(isChrome)
// screen
console.log(screen.width)
console.log(screen.height)
```
### location 和 history
``` javascript
// location
console.log(location.href)
console.log(location.protocol) // 'http:' 'https:'
console.log(location.pathname)
console.log(location.search)
console.log(location.hash)
// history
history.back()
history.forward()
```
# chapter 8 JS-Web-API-事件
### 题目
* 编写一个通用的事件监听函数
  > 考虑代理和通用 代码见 event-demo.js
* 描述事件冒泡的流程
  * 基于 DOM 树形结构
  * 事件会顺着触发元素向上冒泡
  * 应用场景：代理
* 无限上滑的图片列表，如何监听每个图片的点击？
  * 事件代理
  * 用 e.target 获取触发元素
  * 用 matches 来判断是否是触发元素
### 知识点
* 事件绑定
* 事件冒泡
* 事件代理

### 事件绑定
> 代码见 event-demo.js
### 事件冒泡
> 代码见 event-demo.js
### 事件代理
* 代码简洁
* 减少浏览器内存占用
* 但是不要滥用代理
> 代码见 event-demo.js

# chapter 16 运行环境
* 网页加载过程
* 性能优化
* 安全

### 页面加载过程
* 从输入 url 到渲染出页面的整个过程
    * 下载资源：各个资源类型，下载过程
    * 渲染页面：结合 html css javascript 图片等
* window.onload 和 DOMContentLoaded 的区别
  ``` javascript
  window.addEventListener('load', function () {
    // 页面全部资源加载完才会执行，包括图片、视频、iframe 等
  })
  document.addEventListener('DOMContentLoaded', function () {
    // DOM 渲染完即可执行，此时图片、视频可能还没有加载完
  })
  ```

### 资源的形式
* html 代码
* 媒体文件，如图片、视频等
* javascript css

### 加载过程
* DNS 解析：域名 -> IP 地址
* 浏览器根据 IP 地址向服务器发起 http 请求
* 服务器处理 http 请求，并返回给浏览器

### 渲染过程
* 根据 HTML 代码生成 DOM Tree
* 根据 CSS 代码生成 CSSOM
* 将 DOM Tree 和 CSSOM 整合形成 Render Tree
* 根据 Render Tree 渲染页面
* 遇到 `<script>` 则暂停渲染，优先加载并执行 JS 代码，完成再继续
* 直至把 Render Tree 渲染完成
> css 放在 head 中，js 放在 body 最后

### 性能优化原则
* 多使用内存、缓存或其他方法
* 减少 CPU 计算量，减少网络加载耗时
* 适用于所有编程的性能优化 -- 空间换时间
* 从让加载、渲染更快入手

### 让加载更快
* 减少资源体积：压缩代码
* 减少访问次数：合并代码、SSR服务端渲染、缓存
* 使用更快的网络：CDN

### 让渲染更快
* css 放在 head，js放在 body 下面
* 尽早开始执行 js，用 DOMContentLoaded 触发
* 懒加载（图片懒加载，上滑加载更多）
* 对 DOM 查询进行缓存
* 频繁 DOM 操作，合并到一起插入 DOM 结构
* 节流 throttle 防抖 debounce

### 缓存
* 静态资源加 hash 后缀，根据文件内容自动计算 hash 
* 文件内容不变，则 hash 不变，则 url 不变
* url 和文件不变，则会自动触发 http 缓存机制，返回 304

### 懒加载
``` html
<img id="img1" src="preview.png" data-realsrc="abc.png"/>
<script type="text/javascript">
  var img1 = document.getElementById('img1')
  img1.src = img1.getAttribute('data-realsrc')
</script>
```

### 防抖 debounce
* 监听一个输入框，文字变化后触发 change 事件
* 直接用 keyup 事件，则会频繁触发 change 事件
* 防抖：用户输入结束或暂停时，才会触发 change 事件

### 节流 throttle
* 拖拽一个元素时，要随时拿到该元素被拖拽的位置
* 直接用 drag 事件，则会频繁触发，很容易导致卡顿
* 节流：无论拖拽速度多快，都会每隔 100ms 触发一次

### 安全
* 问题：常见的 web 前端攻击方式有哪些？
* XSS 跨站请求攻击
* XSRF 跨站请求伪造
  
### XSS 攻击