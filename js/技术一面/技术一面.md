# chapter 1
### 知识点
* css
  * 布局
  * 定位
  * 移动端响应式
* ES 语法
  * 原型 原型链
  * 作用域 闭包
  * 异步 单线程
* Web API
  * DOM BOM
  * Ajax 跨域
  * 事件 存储
* 开发环境
  * 版本管理
  * 调试抓包
  * 打包构建
* 运行环境
  * 页面渲染
  * 性能优化
  * Web 安全
* 网络通讯
  * headers
  * Restful API
  * 缓存策略

# chapter 2
### typeof 运算符
* 识别所有值类型：undefined string number boolean symbol
* 识别函数：function
* 判断是否是引用类型（不可再细分）：object
``` javascript
typeof console.log // 'function'
typeof function(){} // 'function'
typeof null // 'object'
typeof ['a', 'b'] // 'object'
typeof { x: 100 } // 'object'
```

### 深拷贝
* 代码见 deepClone.js

### 变量计算 - 类型转换
* 字符串拼接
* ==
* if 语句和逻辑运算
``` javascript
const a = 100 + 10 // 110
const b = 100 + '10' // '10010'
const c = true + '10' // 'true10'

100 == '100' // true
0 == '' // true
0 == false // true
false == '' // true
null == undefined // true

// 除了 == null 之外，其他都一律用 === ，例如：
const obj = { x: 100 }
if (obj.a == null) {} // 简写
// 相当于 if (obj.a === null || obj.a === undefined) {}

// 以下都是 falsely 变量，除此之外都是 truely 变量
!!0 === false
!!NaN === false
!!'' === false
!!null === false
!!undefined === false
!!false === false

10 && 0 // 0
'' || 'abc' // 'abc'
!window.abc // true
```
### 小结
* 值类型 vs 引用类型，堆栈模型，深拷贝
* typeof 运算符
* 类型转换，truly 和 falsely 变量

## chapter 3
### 原型和原型链
* 如何准确判断一个变量是不是数组？
  * a instanceof Array
* 手写一个简易的 jQuery ，考虑插件和扩展性
  * 代码见 jquery-demo
* class 的原型本质，怎么理解？
  * 原型和原型链的图示
  * 属性和方法的执行规则

### class
* constructor
* 属性
* 方法
* 代码见 class-demo.js

### 继承
* extends
* super
* 扩展或重写方法
* 代码见 class-demo.js

### 类型判断 - instanceof
``` javascript
// 基于 class-demo
xiaoming instanceof Student
xiaoming instanceof People)
xiaoming instanceof Object
[] instanceof Array // true
[] instanceof Object // true
{} instanceof Object // true
```

### 原型
``` javascript
// 基于 class-demo
// class 实际上是函数，可见是一种语法糖
typeof People // 'function'
typeof Student // 'function'

// 隐式原型和显式原型
xiaoming.__proto__
Student.prototype
xiaoming.__proto === Student.prototype // true
```

### 原型关系
* 每个 class 都有显式原型 prototype
* 每个实例都有隐式原型 \_\_proto\_\_
* 实例的 \_\_proto\_\_ 指向对应 class 的 prototype

### 基于原型的执行规则
* 获取属性 xiaoming.name 或执行方法 xiaoming.sayHi() 时
* 先在自身属性和方法寻找
* 如果找不到则自动去 \_\_proto\_\_ 中查找

### 原型链
``` javascript
// 基于 class-demo
Student.prototype.__proto__
People.prototype
Student.prototype.__proto__ === People.prototype
```
> `xiaoming instanceof Studeng // true`   
> xiaoming 顺着原型链往上找 能否找到 Student.prototype

### 小结
* class 和继承，结合上面手写 jQuery 的示例来理解
* instanceof
* 原型和原型链：图示 & 执行规则

# chapter 5 异步和单线程
### 题目
* 同步和异步的区别是什么？  
* 手写用 promise 加载一张图片
  > 代码见 promise-demo.js
* 前端使用异步的场景有哪些？
* setTimeout 笔试题
  ``` javascript
  console.log(1)
  setTimeout(function() {
    console.log(2)
  }, 1000)
  console.log(3)
  setTimeout(function() {
    console.log(4)
  }, 0)
  console.log(5)
  ```
### 知识点
* 单线程和异步
* 应用场景
* callback hell 和 promise

### 单线程和异步
* JS 是单线程语言，只能同时做一件事
* 浏览器和 nodejs 已支持 JS 启动进程，如 web worker
* JS 和 dom 渲染共用同一个线程，因为 JS 可修改 dom 结构
* 遇到等待（网络请求，定时任务）不能卡住
* 需要异步
* 回调 callback 函数形式

### 异步和同步
* 基于 JS 是单线程语言
* 异步不会阻塞代码执行
* 同步会阻塞代码执行

### 应用场景
* 网络请求，如 ajax 图片加载
* 定时任务，如 setTimeout

### callback hell
``` javascript
// 获取第一份数据
$.get(url1, data1 => {
  console.log(data1)
  // 获取第二份数据
  $.get(url2, data2 => {
    console.log(data2)
    // 获取第三份数据
    $.get(url3, data3 => {
      console.log(data3)
      // 还可能获取更多数据
    })
  })
})
```
### promise
``` javascript
function getData(url) {
  return new Promise((resolve, reject) => {
    $.ajax({
      url,
      success(data) {
        resolve(data)
      },
      error(err) {
        reject(err)
      }
    })
  })
}
const url1 = '/data1.json'
const url2 = '/data2.json'
const url3 = '/data3.json'
getData(url1).then(data1 => {
  console.log(data1)
  return getData(url2)
}).then(data2 => {
  console.log(data2)
  return getData(url3)
}).then(data3 => {
  console.log(data3)
}).catch(err => {
  console.error(err)
})
```

# chapter 10 JS-Web-API-BOM (Browser Object Model)
### 题目
* 如何识别浏览器的类型 navigarot
* 分析拆解 url 各个部分 location
### 知识点
* navigator
* screen
* location
* history
### navigator 和 screen
``` javascript
// navigator
const ua = navigator.userAgent
const isChrome = ua.indexOf('Chrome') !== -1
console.log(isChrome)
// screen
console.log(screen.width)
console.log(screen.height)
```
### location 和 history
``` javascript
// location
console.log(location.href)
console.log(location.protocol) // 'http:' 'https:'
console.log(location.pathname)
console.log(location.search)
console.log(location.hash)
// history
history.back()
history.forward()
```
# chapter 8 JS-Web-API-事件
### 题目
* 编写一个通用的事件监听函数
  > 考虑代理和通用 代码见 event-demo.js
* 描述事件冒泡的流程
  * 基于 DOM 树形结构
  * 事件会顺着触发元素向上冒泡
  * 应用场景：代理
* 无限上滑的图片列表，如何监听每个图片的点击？
  * 事件代理
  * 用 e.target 获取触发元素
  * 用 matches 来判断是否是触发元素
### 知识点
* 事件绑定
* 事件冒泡
* 事件代理

### 事件绑定
> 代码见 event-demo.js
### 事件冒泡
> 代码见 event-demo.js
### 事件代理
* 代码简洁
* 减少浏览器内存占用
* 但是不要滥用代理
> 代码见 event-demo.js

# chapter 14 HTTP 面试题
### 题目
* http 常见的状态码有哪些？
* http 常见的 header 有哪些？
* 什么是 Restful API
* 描述一下 http 的缓存机制（重要）

### http 状态码
* 状态码分类
  * 1xx 服务器收到请求
  * 2xx 请求成功 如200
  * 3xx 重定向 如302
  * 4xx 客户端错误 如404
  * 5xx 服务端错误 如500
* 常见状态码
  * 200 成功
  * 301 永久重定向（配合location，浏览器自动处理）浏览器下次直接访问新地址
  * 302 临时重定向（配合location，浏览器自动处理）浏览器下次仍然访问老地址 应用：短网址、百度搜索时会先跳转百度的链接 再通过302到目标网址
  * 304 资源未被修改
  * 404 资源未找到
  * 403 没有权限
  * 500 服务器错误
  * 504 网关超时

### Restful API
* 传统 API 设计：把每个 url 当做一个功能
* Restful API 设计：把每个 url 当做一个唯一的资源
* 如何设计成一个资源？
  * 尽量不用 url 参数
  * 用 method 表示操作类型

### http headers
* 常见的 Request Headers
  * Accept 浏览器可接收的数据格式
  * Accept-Encoding 浏览器可接收的压缩算法，如 gzip
  * Accept-Language 浏览器可接收的语言，如 zh-CN
  * Connection: keep-alive 一次TCP连接重复使用
  * Cookie
  * Host 请求的域名
  * User-Agent 浏览器信息
  * Content-type 发送数据的格式，如 application/json
* 常见的 Response Headers
  * Content-type 返回数据的格式，如 application/json
  * Content-length 返回数据的大小，多少字节
  * Content-Encoding 返回数据的压缩算法，如 gzip
  * Set-Cookie
* 自定义 header
  * `headers: {'X-Requestd-With': 'XMLHttpRequest'}`
* 缓存相关的 headers
  * Cache-Control Expires
  * Last-Modified If-Modified-Since
  * Etag If-None-Match

### 强制缓存
* 客户端缓存资源
* Cache-Control
  * 在 response headers 中
  * 控制强制缓存的逻辑
  * 例如 Cache-Control: max-age=31536000 (单位是秒) 缓存一年
  * Cache-Control 的值：max-age no-cache no-store private public
* 关于 Expires
  * 同在 response headers 中
  * 同为控制缓存过期
  * 已被 Cache-Control 代替
### 协商缓存
* 服务器端缓存策略
* 服务器判断客户端资源，是否和服务端资源一样
* 一致则返回304，否则返回200和最新的资源
* 客户端初次请求，服务端返回资源和资源标识；客户端带着资源标识再次请求，服务端判断标识是否有效，返回304或者新的资源和新的标识
* 资源标识
  * 在 Response Headers 中，有两种
  * Last-Modified 资源的最后修改时间 客户端带着 If-Modified-Since
  * Etag 资源的唯一标识（一个字符串，类似hash） 客户端带着 If-None-Match
  * 会优先使用 Etag ，Last-Modified 只能精确到秒级，且如果资源被重复生成，而内容不变，则 Etag更精确

### 刷新操作
* 正常操作：强制缓存有效，协商缓存有效 访问url 跳转链接 前进后退
* 手动刷新：强制缓存失效，协商缓存有效 f5
* 强制刷新：强制缓存失效，协商缓存失效 ctrl + f5

# chapter 15 开发环境
* git
* 调试工具
* 抓包
* webpack babel
* linux 常用命令

### 常用 git 命令
``` bash
git add .
git checkout xxx
git commit -m 'xxx'
git push origin master
git pull origin master
git branch
git checkout -b xxx / git checkout xxx
git merge xxx
```

### webpack 和 babel
> 代码见 webpack-demo

<!-- todo 15-8 -->
### linux 命令
``` bash
ssh work@192.168.0.1 // 连接服务器 work是用户名
ls -a // 显示所有文件
ll // 列表形式看文件
mkdir abc // 创建abc文件夹
rm -rf abc // 删除文件夹
mv index.js index1.js // 修改文件名为 index1.js
mv bundle.js ../bundle.js // 移动文件到上级目录
cp a.js a1.js // 复制a.js 设置名为a1.js
touch d.js // 新建d.js
vi d.js // 新建d.js 并且进入vim编辑器
cat head tail // 查看文件/文件前几行/后几行
grep "babel" package.json // 查找关键字
```

# chapter 16 运行环境
* 网页加载过程
* 性能优化
* 安全

### 页面加载过程
* 从输入 url 到渲染出页面的整个过程
    * 下载资源：各个资源类型，下载过程
    * 渲染页面：结合 html css javascript 图片等
* window.onload 和 DOMContentLoaded 的区别
  ``` javascript
  window.addEventListener('load', function () {
    // 页面全部资源加载完才会执行，包括图片、视频、iframe 等
  })
  document.addEventListener('DOMContentLoaded', function () {
    // DOM 渲染完即可执行，此时图片、视频可能还没有加载完
  })
  ```

### 资源的形式
* html 代码
* 媒体文件，如图片、视频等
* javascript css

### 加载过程
* DNS 解析：域名 -> IP 地址
* 浏览器根据 IP 地址向服务器发起 http 请求
* 服务器处理 http 请求，并返回给浏览器

### 渲染过程
* 根据 HTML 代码生成 DOM Tree
* 根据 CSS 代码生成 CSSOM
* 将 DOM Tree 和 CSSOM 整合形成 Render Tree
* 根据 Render Tree 渲染页面
* 遇到 `<script>` 则暂停渲染，优先加载并执行 JS 代码，完成再继续
* 直至把 Render Tree 渲染完成
> css 放在 head 中，js 放在 body 最后

### 性能优化原则
* 多使用内存、缓存或其他方法
* 减少 CPU 计算量，减少网络加载耗时
* 适用于所有编程的性能优化 -- 空间换时间
* 从让加载、渲染更快入手

### 让加载更快
* 减少资源体积：压缩代码
* 减少访问次数：合并代码、SSR服务端渲染、缓存
* 使用更快的网络：CDN

### 让渲染更快
* css 放在 head，js放在 body 下面
* 尽早开始执行 js，用 DOMContentLoaded 触发
* 懒加载（图片懒加载，上滑加载更多）
* 对 DOM 查询进行缓存
* 频繁 DOM 操作，合并到一起插入 DOM 结构
* 节流 throttle 防抖 debounce

### 缓存
* 静态资源加 hash 后缀，根据文件内容自动计算 hash 
* 文件内容不变，则 hash 不变，则 url 不变
* url 和文件不变，则会自动触发 http 缓存机制，返回 304

### 懒加载
``` html
<img id="img1" src="preview.png" data-realsrc="abc.png"/>
<script type="text/javascript">
  var img1 = document.getElementById('img1')
  img1.src = img1.getAttribute('data-realsrc')
</script>
```

### 防抖 debounce
* 监听一个输入框，文字变化后触发 change 事件
* 直接用 keyup 事件，则会频繁触发 change 事件
* 防抖：用户输入结束或暂停时，才会触发 change 事件

### 节流 throttle
* 拖拽一个元素时，要随时拿到该元素被拖拽的位置
* 直接用 drag 事件，则会频繁触发，很容易导致卡顿
* 节流：无论拖拽速度多快，都会每隔 100ms 触发一次

### 安全
* 问题：常见的 web 前端攻击方式有哪些？
* XSS 跨站请求攻击
* XSRF 跨站请求伪造
  
### XSS 预防
* 替换特殊字符，如 `<` 变为 `&lt;` `>` 变为 `&gt;`
* `<script>` 变为 `&lt;script&gt;` 直接显示，而不会作为脚本执行
* 前后端可以都做替换，双重保险

### XSRF 预防
* 使用 post 接口
* 增加验证，例如密码、短信验证码等

# chapter 17 课程总结
思维导图见 xmind

# chapter 18 真题
### 介绍 RAF requestAnimationFrame
* 要想动画流畅，更新频率要 60 帧每秒，即 16.67ms 更新一次视图
* setTimeout 要手动控制频率，而 RAF 浏览器会自动控制
* 后台标签或隐藏 iframe 中，RAF 会暂停，而 setTimeout 依然执行
> 代码见 raf.html

### 如何性能优化 从哪几个方面考虑
